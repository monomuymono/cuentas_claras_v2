AIzaSyDMhW9Fxz2kLG7HszVnBDmgQMJwzXSzd9U

https://script.google.com/macros/s/AKfycbzcp2CFlrnDnIzmRadn553OYMNYXo5AldaGdnmsisgt8O3Qm07tHj5iWGh9dCdg-leQ/exec

{
  "postData": {
    "contents": "{\"action\":\"save\",\"shareId\":\"test_session_123\",\"data\":{\"comensales\":[{\"id\":1,\"name\":\"Juan\",\"selectedItems\":[],\"total\":0}],\"availableProducts\":{},\"totalGeneralMesa\":0,\"propinaSugerida\":0,\"activeSharedInstances\":{}}}"
  }
}


{
  "action": "save",
  "shareId": "mi_id_de_prueba_app_react",
  "data": {
    "comensales": [
      {"id":1,"name":"Alice","selectedItems":[],"total":0}
    ],
    "availableProducts": {},
    "totalGeneralMesa": 10000,
    "propinaSugerida": 1000,
    "activeSharedInstances": {}
  }
}

/**
 * @fileoverview
 * Google Apps Script para actuar como un backend simple usando una Hoja de Cálculo de Google.
 *
 * =======================================================================================
 * === ¡ACCIÓN CRÍTICA REQUERIDA! ===
 * =======================================================================================
 * Si el script falla con "addHeader no es una función", el entorno de ejecución puede estar corrupto.
 * Para solucionarlo:
 * 1. Haz clic en 'Configuración del Proyecto' (icono de engranaje ⚙️) a la izquierda.
 * 2. Marca la casilla 'Mostrar el archivo de manifiesto "appsscript.json" en el editor'.
 * 3. Vuelve al Editor (<>) y abre el nuevo archivo `appsscript.json`.
 * 4. Pega el siguiente contenido en él:
 *
 * {
 * "timeZone": "America/New_York",
 * "dependencies": {},
 * "exceptionLogging": "STACKDRIVER",
 * "runtimeVersion": "V8"
 * }
 *
 * 5. Guarda ambos archivos y vuelve a ejecutar la función 'testEnvironment'.
 * =======================================================================================
 *
 * Funcionalidad:
 * - Guarda (POST), carga (GET) y elimina (POST con acción 'delete') sesiones de datos JSON.
 * - Maneja solicitudes CORS (OPTIONS) para permitir el acceso desde aplicaciones web externas.
 * - Se requiere una configuración única ejecutando `setupSheetHeaders` manualmente.
 */

// --- CONFIGURACIÓN ---
const SPREADSHEET_ID = 'YOUR_GOOGLE_SHEET_ID_HERE'; // <<-- ¡REEMPLAZA ESTO!
const SHEET_NAME = 'Sessions'; // Asegúrate de que este nombre coincida con el de tu hoja.


/**
 * FUNCIÓN DE DIAGNÓSTICO: Ejecuta esta función manualmente desde el editor.
 */
function testEnvironment() {
  try {
    console.log("Iniciando prueba de entorno con runtime V8 forzado...");
    const output = ContentService.createTextOutput("Prueba");
    
    if (typeof output.addHeader === 'function') {
      output.addHeader("X-Test-Header", "Success");
      const message = "¡Prueba V8 exitosa! El método 'addHeader' funciona. Ahora puedes desplegar la aplicación web.";
      console.log(message);
      SpreadsheetApp.getUi().alert(message);
    } else {
      throw new Error("¡ERROR CRÍTICO! El método 'addHeader' NO se encontró o no es una función, incluso con el runtime V8.");
    }
  } catch (e) {
    const errorMessage = "Error en la prueba de entorno V8: " + e.toString();
    console.error(errorMessage);
    SpreadsheetApp.getUi().alert(errorMessage);
  }
}


/**
 * Función auxiliar para obtener el objeto de la hoja de cálculo.
 * @returns {GoogleAppsScript.Spreadsheet.Sheet} La hoja de trabajo.
 */
function getSheet() {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAME);
  if (!sheet) {
    throw new Error('Hoja no encontrada: ' + SHEET_NAME + '. Asegúrate de que el nombre sea correcto.');
  }
  return sheet;
}

/**
 * CONFIGURACIÓN INICIAL: Ejecutar esta función manualmente UNA VEZ desde el editor.
 */
function setupSheetHeaders() {
  try {
    const sheet = getSheet();
    const headers = sheet.getRange("A1:B1").getValues()[0];
    if (sheet.getLastRow() < 1 || headers[0] !== "shareId" || headers[1] !== "JSON_DATA") {
      sheet.clear();
      sheet.getRange("A1:B1").setValues([["shareId", "JSON_DATA"]]);
      console.log("Encabezados de la hoja configurados correctamente.");
    } else {
      console.log("Los encabezados de la hoja ya son correctos.");
    }
  } catch (e) {
    console.error("Error al configurar los encabezados de la hoja: " + e.toString());
    throw e;
  }
}

/**
 * Maneja las solicitudes pre-vuelo OPTIONS para CORS. NO EJECUTAR MANUALMENTE.
 * @param {object} e El objeto del evento de la solicitud.
 * @returns {GoogleAppsScript.Content.TextOutput} La respuesta con las cabeceras CORS.
 */
function doOptions(e) {
  console.log("Recibida solicitud OPTIONS. Construyendo respuesta CORS.");
  return ContentService.createTextOutput()
    .addHeader('Access-Control-Allow-Origin', '*')
    .addHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS')
    .addHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
}

/**
 * Maneja las solicitudes GET. NO EJECUTAR MANUALMENTE.
 * @param {object} e El objeto del evento.
 * @returns {GoogleAppsScript.Content.TextOutput} La respuesta JSON.
 */
function doGet(e) {
  try {
    const shareId = e.parameter.id;
    if (!shareId) {
        throw new Error("No se proporcionó 'id' en la solicitud GET.");
    }

    const sheet = getSheet();
    const data = sheet.getDataRange().getValues();
    let sessionData = null;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == shareId) {
        sessionData = data[i][1];
        break;
      }
    }
    
    const responseJson = sessionData ? sessionData : JSON.stringify({ status: "not_found", message: "No data found for the provided id." });

    return ContentService.createTextOutput(responseJson)
      .setMimeType(ContentService.MimeType.JSON)
      .addHeader('Access-Control-Allow-Origin', '*');

  } catch (error) {
    console.error("Error en doGet:", error.toString());
    const errorOutput = ContentService.createTextOutput(JSON.stringify({ status: 'error', message: error.message }))
      .setMimeType(ContentService.MimeType.JSON)
      .addHeader('Access-Control-Allow-Origin', '*');
    return errorOutput;
  }
}

/**
 * Maneja las solicitudes POST. NO EJECUTAR MANUALMENTE.
 * @param {object} e El objeto del evento.
 * @returns {GoogleAppsScript.Content.TextOutput} La respuesta JSON con el estado de la operación.
 */
function doPost(e) {
  try {
    const requestData = JSON.parse(e.postData.contents);
    const { action, shareId, data: dataToSave } = requestData;

    if (!action || !shareId) {
        throw new Error("La solicitud debe incluir 'action' y 'shareId'.");
    }

    const sheet = getSheet();
    const data = sheet.getDataRange().getValues();
    let response = { status: 'error', message: 'Acción no válida o ID no encontrado.' };
    let rowFound = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == shareId) {
        rowFound = i + 1;
        break;
      }
    }

    if (action === 'save') {
      if (typeof dataToSave === 'undefined') throw new Error("La acción 'save' requiere un campo 'data'.");
      
      const jsonDataString = JSON.stringify(dataToSave);
      if (rowFound > -1) {
        sheet.getRange(rowFound, 2).setValue(jsonDataString);
        response = { status: 'success', message: 'Datos actualizados correctamente.' };
      } else {
        sheet.appendRow([shareId, jsonDataString]);
        response = { status: 'success', message: 'Datos guardados correctamente.' };
      }
    } else if (action === 'delete') {
      if (rowFound > -1) {
        sheet.deleteRow(rowFound);
        response = { status: 'success', message: 'Datos eliminados correctamente.' };
      } else {
        response = { status: 'not_found', message: 'No se encontraron datos para eliminar.' };
      }
    }

    return ContentService.createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON)
      .addHeader('Access-Control-Allow-Origin', '*');

  } catch (error) {
    console.error("Error en doPost:", error.toString());
    const errorOutput = ContentService.createTextOutput(JSON.stringify({ status: 'error', message: error.message }))
      .setMimeType(ContentService.MimeType.JSON)
      .addHeader('Access-Control-Allow-Origin', '*');
    return errorOutput;
  }
}

